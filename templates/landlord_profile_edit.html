# landlord/profile.py
from __future__ import annotations

import io
import os
import re
import sqlite3
from datetime import datetime as dt
from pathlib import Path
from typing import Optional, Tuple

from flask import Blueprint, render_template, request, redirect, url_for, flash
from PIL import Image

from db import get_db
from utils import require_landlord, current_landlord_id

bp = Blueprint("landlord", __name__)  # keep your existing import/registration if different

# -------------------------------------------------------------------
# Config
# -------------------------------------------------------------------
STATIC_ROOT = Path("/opt/render/project/src/static")
LANDLORD_UPLOADS = STATIC_ROOT / "uploads" / "landlords"   # /static/uploads/landlords/<lid>/
LANDLORD_UPLOADS.mkdir(parents=True, exist_ok=True)

ALLOWED_IMAGE_EXT = {".jpg", ".jpeg", ".png", ".webp", ".gif"}
MAX_SIDE = 1600  # same as photos cap; safe + light
JPEG_QUALITY = 85

# -------------------------------------------------------------------
# Helpers
# -------------------------------------------------------------------
def _norm_display_name(s: str) -> str:
    s = (s or "").strip()
    return s[:20]  # hard cap per spec

def _norm_phone(s: str) -> str:
    s = (s or "").strip()
    if not s:
        return ""
    # simple tidy: keep digits and leading +
    s = re.sub(r"[^\d+]", "", s)
    # collapse multiple +'s
    s = re.sub(r"\++", "+", s)
    # if it starts with 00, make it + (e.g., 0044 -> +44)
    if s.startswith("00"):
        s = "+" + s[2:]
    return s[:32]

def _norm_website(u: str) -> str:
    u = (u or "").strip()
    if not u:
        return ""
    if not re.match(r"^https?://", u, flags=re.I):
        u = "https://" + u
    # very light sanity check: must contain at least one dot
    if "." not in u.split("://", 1)[-1]:
        return ""
    return u[:200]

def _norm_bio(s: str) -> str:
    s = (s or "").strip()
    return s[:1200]

def _allowed_file_ext(filename: str) -> bool:
    ext = os.path.splitext(filename or "")[1].lower()
    return ext in ALLOWED_IMAGE_EXT

def _ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)

def _process_image_no_watermark(stream: io.BytesIO, out_path: Path) -> Tuple[int, int, int]:
    """
    Open image, auto-rotate via EXIF, convert to RGB,
    resize longest side = MAX_SIDE, save JPEG @ QUALITY.
    Return (width, height, bytes).
    """
    stream.seek(0)
    with Image.open(stream) as im:
        try:
            im = ImageOps.exif_transpose(im)  # type: ignore
        except Exception:
            pass
        if im.mode not in ("RGB", "L"):
            im = im.convert("RGB")
        else:
            im = im.convert("RGB")

        w, h = im.size
        scale = 1.0
        if max(w, h) > MAX_SIDE:
            scale = MAX_SIDE / float(max(w, h))
            w = int(round(w * scale))
            h = int(round(h * scale))
            im = im.resize((w, h), Image.LANCZOS)

        _ensure_dir(out_path.parent)
        # save as JPEG
        buf = io.BytesIO()
        im.save(buf, format="JPEG", quality=JPEG_QUALITY, progressive=True, optimize=True)
        data = buf.getvalue()
        out_path.write_bytes(data)
        return (w, h, len(data))

def _get_profile(conn: sqlite3.Connection, landlord_id: int):
    row = conn.execute("""
        SELECT lp.*, l.email
          FROM landlord_profiles lp
          JOIN landlords l ON l.id = lp.landlord_id
         WHERE lp.landlord_id=?
    """, (landlord_id,)).fetchone()
    if not row:
        # seed a profile row if missing
        conn.execute("""
            INSERT OR IGNORE INTO landlord_profiles(landlord_id, display_name, phone, website, bio, public_slug, profile_views, is_verified, role)
            VALUES (?, '', '', '', '', NULL, 0, 0, 'owner')
        """, (landlord_id,))
        conn.commit()
        row = conn.execute("""
            SELECT lp.*, l.email
              FROM landlord_profiles lp
              JOIN landlords l ON l.id = lp.landlord_id
             WHERE lp.landlord_id=?
        """, (landlord_id,)).fetchone()
    return row

def _slugify(name: str) -> str:
    base = re.sub(r"[^A-Za-z0-9]+", "-", name.strip().lower()).strip("-")
    return (base or "landlord")[:60]

def _ensure_public_slug(conn: sqlite3.Connection, landlord_id: int, display_name: str) -> None:
    if not display_name:
        return
    row = conn.execute(
        "SELECT public_slug FROM landlord_profiles WHERE landlord_id=?",
        (landlord_id,)
    ).fetchone()
    if row and row["public_slug"]:
        return
    slug = _slugify(display_name)
    # ensure unique
    unique = slug
    n = 1
    while conn.execute("SELECT 1 FROM landlord_profiles WHERE public_slug=?", (unique,)).fetchone():
        n += 1
        unique = f"{slug}-{n}"
    conn.execute("UPDATE landlord_profiles SET public_slug=? WHERE landlord_id=?", (unique, landlord_id))
    conn.commit()

# -------------------------------------------------------------------
# Route: Edit profile (GET + POST, plus upload actions)
# -------------------------------------------------------------------
@bp.route("/landlord/profile", methods=["GET", "POST"])
def landlord_profile_edit():
    r = require_landlord()
    if r:
        return r
    lid = current_landlord_id()
    conn = get_db()

    profile = _get_profile(conn, lid)

    # Distinguish actions:
    action = (request.form.get("action") or "").strip()

    # ---------------------------------------
    # Upload/Remove: LOGO
    # ---------------------------------------
    if request.method == "POST" and action in ("upload_logo", "remove_logo"):
        if action == "remove_logo":
            conn.execute(
                "UPDATE landlord_profiles SET logo_path='' WHERE landlord_id=?",
                (lid,)
            )
            conn.commit()
            flash("Logo removed.", "ok")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))

        file = request.files.get("logo")
        if not file or not file.filename:
            flash("Please choose a logo file to upload.", "error")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))
        if not _allowed_file_ext(file.filename):
            flash("Unsupported logo format. Please upload JPG/PNG/WebP/GIF.", "error")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))

        # Process → save to /static/uploads/landlords/<lid>/logo.jpg
        lid_dir = LANDLORD_UPLOADS / str(lid)
        out_path = lid_dir / "logo.jpg"
        try:
            data = io.BytesIO(file.read())
            _process_image_no_watermark(data, out_path)
        except Exception as e:
            flash("Could not process logo. Please try a different image.", "error")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))

        rel_path = str(out_path.relative_to(STATIC_ROOT)).replace("\\", "/")  # e.g., uploads/landlords/12/logo.jpg
        conn.execute("UPDATE landlord_profiles SET logo_path=? WHERE landlord_id=?", (rel_path, lid))
        conn.commit()
        flash("Logo uploaded.", "ok")
        conn.close()
        return redirect(url_for("landlord.landlord_profile_edit"))

    # ---------------------------------------
    # Upload/Remove: PHOTO
    # ---------------------------------------
    if request.method == "POST" and action in ("upload_photo", "remove_photo"):
        if action == "remove_photo":
            conn.execute(
                "UPDATE landlord_profiles SET photo_path='' WHERE landlord_id=?",
                (lid,)
            )
            conn.commit()
            flash("Profile photo removed.", "ok")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))

        file = request.files.get("photo")
        if not file or not file.filename:
            flash("Please choose a photo to upload.", "error")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))
        if not _allowed_file_ext(file.filename):
            flash("Unsupported photo format. Please upload JPG/PNG/WebP/GIF.", "error")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))

        # Process → save to /static/uploads/landlords/<lid>/photo.jpg
        lid_dir = LANDLORD_UPLOADS / str(lid)
        out_path = lid_dir / "photo.jpg"
        try:
            data = io.BytesIO(file.read())
            _process_image_no_watermark(data, out_path)
        except Exception:
            flash("Could not process photo. Please try a different image.", "error")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))

        rel_path = str(out_path.relative_to(STATIC_ROOT)).replace("\\", "/")
        conn.execute("UPDATE landlord_profiles SET photo_path=? WHERE landlord_id=?", (rel_path, lid))
        conn.commit()
        flash("Profile photo uploaded.", "ok")
        conn.close()
        return redirect(url_for("landlord.landlord_profile_edit"))

    # ---------------------------------------
    # Standard profile SAVE (left-hand form)
    # ---------------------------------------
    if request.method == "POST" and not action:
        display_name = _norm_display_name(request.form.get("display_name", ""))
        phone        = _norm_phone(request.form.get("phone", ""))
        website      = _norm_website(request.form.get("website", ""))
        bio          = _norm_bio(request.form.get("bio", ""))
        role_raw     = (request.form.get("role") or "owner").strip().lower()
        role         = role_raw if role_raw in ("owner", "agent") else "owner"

        if not display_name:
            flash("Display name is required.", "error")
            conn.close()
            return redirect(url_for("landlord.landlord_profile_edit"))

        conn.execute("""
            UPDATE landlord_profiles
               SET display_name=?,
                   phone=?,
                   website=?,
                   bio=?,
                   role=?
             WHERE landlord_id=?
        """, (display_name, phone, website, bio, role, lid))
        conn.commit()

        # ensure public slug exists after first valid display name
        _ensure_public_slug(conn, lid, display_name)

        flash("Profile saved.", "ok")
        conn.close()
        return redirect(url_for("landlord.landlord_profile_edit"))

    # GET:
    profile = _get_profile(conn, lid)
    conn.close()
    return render_template(
        "landlord_profile_edit.html",
        profile=profile,
        email=(profile["email"] if profile else None),
        contact_email=(profile["email"] if profile else None),
    )
