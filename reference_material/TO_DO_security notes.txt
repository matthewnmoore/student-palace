SECURITY NOTE — Tenant/Landlord Authorization (Critical)






How to roll out without making the site unusable

Phase A — Totally safe changes (can stop anytime)

These won’t block users even if you pause halfway.
	1.	Add the ownership helper functions (don’t enable yet).
	2.	Add security headers (CSP/HSTS/X-Frame-Options/nosniff).
	3.	Turn on secure cookies + sensible session timeout.
	4.	Add rate limits to login/signup/delete/upload (reasonable caps).
	5.	Add CAPTCHA but set it to adaptive (only appears after a few failed attempts).
	6.	Backups + deny logging (extra logs if someone hits a forbidden path).

If you stop here: site keeps working normally.

⸻

Phase B — Ownership checks in “log-only” (non-blocking)

Goal: see what would be blocked, without blocking it yet.
	1.	Add a simple switch (env var) like OWNERSHIP_ENFORCEMENT=monitor.
	2.	Start inserting the one line ownership check at the top of one file at a time (e.g., landlord/photos.py, then rooms.py, etc.).
	3.	In monitor mode, failed checks log a warning but do not abort.

If you stop here: site still works; you just gather evidence of any places you missed.

⸻

Phase C — Flip on enforcement per area (small slices)

Turn on real blocking for one area at a time; pause anytime.
	1.	Set OWNERSHIP_ENFORCEMENT=photos → only photos abort on failure.
	2.	Watch logs, do a quick smoke test.
	3.	Next, =photos,rooms. Then =photos,rooms,houses.
	4.	Finally, =all.

If you stop here: only the areas you’ve flipped are enforced; the rest behave as before.

⸻

Phase D — Gated downloads (no image breakages)

Done carefully so images don’t vanish:
	1.	Create the new download URLs for photos/floorplans/EPC (they re-check ownership).
	2.	Update templates to use the new URLs first.
	3.	Keep the old /static paths alive for a short overlap (just in case).
	4.	Once you’ve clicked around and it’s fine, remove the old direct links.

If you stop mid-way: both old and new links work; site stays usable.

⸻

Phase E — CSRF (won’t break if you stage it)
	1.	Enable CSRF globally but temporarily exempt landlord/admin blueprints.
	2.	Add the CSRF token to landlord/admin forms.
	3.	Remove the exemptions.

If you stop after step 1 or 2: site still works; nothing breaks.

⸻

Safety rails (use these and you’re golden)
	•	Feature flags/switches (env vars, no code change needed to toggle):
	•	OWNERSHIP_ENFORCEMENT: off → monitor → photos → rooms → houses → all
	•	CAPTCHA_MODE: off → adaptive → always
	•	CSRF_EXEMPT_LANDLORD: true/false (use while wiring tokens)
	•	Small slices: change one file or feature area, test, then move on.
	•	Rollbacks: keep your baseline labels (you already do), so reverting is trivial.
	•	Smoke tests after each slice (2 minutes):
	•	Log in, view/edit your own item → works.
	•	Try another landlord’s ID → should be blocked only where you’ve enabled enforcement.
	•	Upload/delete a photo in your own house → works.

⸻

Bottom line

If you follow that order and use the toggles, you can stop at any time and the site will still be usable. The security gets stronger step-by-step without a “big bang” that locks everyone out.


















Step 1 — One-time prep (do once)
	1.	Open utils.py.
	•	Add/confirm the two ownership helpers exist: house and room.
	•	Add two more tiny helpers: house image and house document (they look up the image/doc → resolve to its house → confirm the house belongs to the logged-in landlord).
(No need to paste code here; the “one line” you’ll call in routes will be: “check house/room/image/doc belongs to me”.)
	2.	Open errors.py.
	•	Make sure 403 (“not allowed”) returns a simple JSON/page.
	3.	Open config.py.
	•	Switch on secure cookies, sensible session timeout.
	4.	Open auth.py (root) + templates/login.html + templates/signup.html.
	•	Drop your CAPTCHA widget on login, signup, password reset (if present).
	•	Server-side: verify the CAPTCHA before proceeding.

⸻

Step 2 — Add the “one line” ownership check (per file)

For each route that accepts an ID, scroll to the top of the view function, and insert one check before any DB read/write. That’s it.

landlord/
	•	houses.py
	•	Routes: list my houses (already scoped), add/edit, delete, any POST actions.
	•	Do: at top of every route with hid, add the house ownership check.
	•	rooms.py
	•	Routes: list rooms for a house, add/edit room, delete.
	•	Do: add house ownership check (for the house list) and room ownership check (for specific room with rid). If both hid and rid are present, check both (room joined to that house).
	•	room_photos.py
	•	Routes: GET/POST photos, set primary, delete.
	•	Do: add room ownership check (and implicitly its parent house).
	•	photos.py
	•	Routes: GET/POST house photos, set primary, delete, /photos/debug (JSON).
	•	Do: add house ownership check on every one. For actions with img_id, also check image belongs to that house.
	•	floorplans.py
	•	Routes: upload/list/delete floorplans, any debug/download endpoints.
	•	Do: add house ownership check on every one; for plan IDs, confirm the plan belongs to that house before action.
	•	epc.py
	•	Routes: upload/list/delete EPC; any download.
	•	Do: add house ownership check; for doc_id, confirm document belongs to that house.
	•	bulk.py
	•	Routes: bulk edit for a house.
	•	Do: add house ownership check right at the top.
	•	portfolio.py / rooms_all.py / rooms_all_edit.py
	•	These show/edit many rooms across the landlord’s portfolio.
	•	Do: ensure the query is scoped by current landlord (no foreign rows). If an action takes hid/rid, add the relevant check at the top.
	•	profile.py / accreditations.py / dashboard.py
	•	If they edit the logged-in landlord’s own profile, no hid/rid checks needed.
	•	If any action touches a specific house/room/image/doc by ID → add the ownership check.
	•	delete.py
	•	If present for hard deletes: ensure ownership check before delete.

✅ Pattern: any landlord route with /<hid>/…, /<hid>/rooms/<rid>/…, …/<img_id>, or …/<doc_id> gets one “is this mine?” line at the top.

⸻

admin/
	•	No ownership checks (admins can access all), but:
	•	Ensure admin login is required.
	•	Keep CSRF on forms; consider rate limit on destructive actions.

⸻

public/ and root pages
	•	public.py, public_property.py, room_public.py, rooms.py (root), app.py
	•	These are public views — no landlord ownership checks.
	•	If any route serves private files, change it to go through a gated download route (see Step 3).

⸻

Step 3 — Lock down files (one replacement)
	1.	Stop linking private files directly from /static/uploads/....
	2.	Create one download route per file type (house photo, room photo, floorplan, epc): it loads by id → resolves parent → runs the same ownership check → streams the file.
	3.	Update templates:
	•	templates/house_photos.html, templates/room_photos.html, templates/house_floorplans.html, templates/house_epc.html
	•	Replace <img src="/static/uploads/..."> and <a href="/static/uploads/..."> with the new download URL that includes the ID (so the server can check).

⸻

Step 4 — Quick template hygiene (2 minutes per page)

Open each landlord template that has a form or action:
	•	Ensure action URLs include the IDs the server expects (e.g., /landlord/houses/{{ house.id }}/photos).
	•	Remove any raw /static/uploads/... links to private files (switch to the gated route from Step 3).

Templates to skim:
house_form.html, room_form.html, house_photos.html, room_photos.html, house_floorplans.html, house_epc.html, landlord_rooms_all_edit.html, any *_delete*.html.

⸻

Step 5 — Abuse controls (attach once)
	•	CAPTCHA: already added in Step 1 to login.html / signup.html (and password reset if you have it).
	•	Rate limits: add to the login, signup, photo upload, delete routes (one small decorator/config each—no template work).

⸻

Step 6 — Your “done” tests (what to try in the browser)
	1.	Log in as Landlord A.
	2.	Manually type a URL to Landlord B’s house/room/photo/doc (change the number in the URL).
	•	You should get Forbidden (403).
	3.	Try to download someone else’s photo/floorplan/EPC via a guessed path.
	•	You should get Forbidden (403).
	4.	Try the debug JSON endpoints under landlord scope with a foreign ID.
	•	Forbidden (403) again.
	5.	Check Network tab on any page → all responses have security headers.

⸻

File-by-file micro-checklist (copy this into your editor and tick)
	•	landlord/houses.py → add ownership line on all routes with hid
	•	landlord/rooms.py → add ownership line on all routes with hid/rid
	•	landlord/photos.py → add ownership line on all routes with hid (and img_id)
	•	landlord/room_photos.py → add ownership line on routes with hid/rid (and img_id)
	•	landlord/floorplans.py → add ownership line on routes with hid (and plan id)
	•	landlord/epc.py → add ownership line on routes with hid (and doc_id)
	•	landlord/bulk.py → add ownership line on bulk routes with hid
	•	landlord/portfolio.py / rooms_all*.py → scope queries to current landlord; add checks on any actions with ids
	•	templates/*photos*.html, house_floorplans.html, house_epc.html → swap direct /static links to gated download URLs
	•	templates/login.html, templates/signup.html (+ reset) → CAPTCHA present; server verifies
	•	config.py → secure cookies + session expiry
	•	errors.py → clean 403 response
	•	Rate limits attached to login/upload/delete endpoints

⸻

If you want, I’ll take one file (say landlord/photos.py) and write the exact “one-liners” you need to paste at the top of each route, plus the small template change for house_photos.html.






















Student Palace Security Rollout Checklist (plain text)
	1.	Ownership checks (IDOR)
	•	Add an “owned_house_or_abort” and “owned_room_or_abort” check.
	•	Apply it to every landlord route (houses, rooms, photos, floorplans, EPC, etc.).
	•	Result: a landlord can only ever touch their own data.
	2.	Authentication hardening
	•	All landlord routes behind login (already true).
	•	Ensure sessions use secure cookies (HttpOnly, Secure, SameSite).
	•	Add logout and session expiry.
	3.	Forms and inputs
	•	Validate everything coming in (choices, numbers, dates).
	•	Sanitize text output with Jinja autoescape (already in place).
	•	File uploads: check type, size, watermark, store outside web root if possible.
	4.	Security headers
	•	Add headers: HSTS, Content-Security-Policy, X-Frame-Options, X-Content-Type-Options.
	•	These cut off whole classes of browser attacks.
	5.	Rate limiting & brute force
	•	Throttle login attempts per IP/account.
	•	Throttle sensitive actions (e.g., photo upload, delete).
	6.	Secrets & config
	•	Keep secrets in environment variables.
	•	Never commit them to GitHub.
	7.	Monitoring
	•	Log denied attempts (403/404).
	•	Keep error logs.
	•	Optional: basic alerting if repeated attacks.
	8.	Backups
	•	Database and uploads backed up daily.
	•	Test restoring at least once.
	9.	External check
	•	Once stable, get a pen tester to run through.
	•	Fix anything critical they find.



















Problem (in plain English)
	•	Our landlord dashboard pages are addressable by predictable IDs (e.g., /landlord/houses/123/edit).
	•	If a route doesn’t verify ownership, a logged-in Landlord A could type Landlord B’s house ID in the URL and view/edit B’s data.
	•	This is an Insecure Direct Object Reference (IDOR) issue. It risks exposure of private data and unauthorized changes.

What “ownership check” means
	•	Every landlord-only route must confirm:
	1.	The user is logged in as a landlord.
	2.	The requested resource (house/room/photo/etc.) belongs to that landlord.

Impact if not fixed
	•	Data leaks (addresses, emails, rooms, images).
	•	Unauthorized edits or deletions.
	•	Compliance/trust issues and potential legal exposure (privacy violation).

How we fix it (high level)
	1.	Require login on all landlord routes (already have require_landlord()).
	2.	Enforce ownership everywhere using a single helper (abort if not owner).
	3.	Use ownership for nested resources (rooms → their house → its landlord).
	4.	Return 403/404 on failures and never reveal whether the target ID exists.

Concrete code pattern (reuse everywhere)






code:
=====

# utils.py (or a shared helpers module)
from flask import abort
from db import get_db

def owned_house_or_abort(conn, hid: int, landlord_id: int):
    row = conn.execute(
        "SELECT id FROM houses WHERE id=? AND landlord_id=?",
        (hid, landlord_id)
    ).fetchone()
    if not row:
        abort(403)  # or 404; choose one policy and be consistent
    return row

def owned_room_or_abort(conn, hid: int, rid: int, landlord_id: int):
    row = conn.execute("""
        SELECT rooms.id FROM rooms
        JOIN houses ON houses.id = rooms.house_id
       WHERE rooms.id=? AND rooms.house_id=? AND houses.landlord_id=?
    """, (rid, hid, landlord_id)).fetchone()
    if not row:
        abort(403)
    return row






    code
    ====
    # utils.py (or a shared helpers module)
from flask import abort
from db import get_db

def owned_house_or_abort(conn, hid: int, landlord_id: int):
    row = conn.execute(
        "SELECT id FROM houses WHERE id=? AND landlord_id=?",
        (hid, landlord_id)
    ).fetchone()
    if not row:
        abort(403)  # or 404; choose one policy and be consistent
    return row

def owned_room_or_abort(conn, hid: int, rid: int, landlord_id: int):
    row = conn.execute("""
        SELECT rooms.id FROM rooms
        JOIN houses ON houses.id = rooms.house_id
       WHERE rooms.id=? AND rooms.house_id=? AND houses.landlord_id=?
    """, (rid, hid, landlord_id)).fetchone()
    if not row:
        abort(403)
    return row









    Usage in routes (example)

@bp.route("/landlord/houses/<int:hid>/edit", methods=["GET","POST"])
def house_edit(hid):
    r = require_landlord()
    if r: return r
    lid = current_landlord_id()

    conn = get_db()
    owned_house_or_abort(conn, hid, lid)  # hard gate
    # ... proceed safely ...





@bp.route("/landlord/houses/<int:hid>/rooms/<int:rid>/edit", methods=["GET","POST"])
def room_edit(hid, rid):
    r = require_landlord()
    if r: return r
    lid = current_landlord_id()

    conn = get_db()
    owned_room_or_abort(conn, hid, rid, lid)  # hard gate for nested resource
    # ... proceed safely ...




    Decorator variant (optional, nice for consistency)
    # utils_auth.py
from functools import wraps
from flask import g, abort
from utils import current_landlord_id
from db import get_db

def owns_house(param_name="hid"):
    def deco(fn):
        @wraps(fn)
        def wrapper(*args, **kwargs):
            lid = current_landlord_id()
            hid = kwargs.get(param_name)
            conn = get_db()
            row = conn.execute(
                "SELECT 1 FROM houses WHERE id=? AND landlord_id=?",
                (hid, lid)
            ).fetchone()
            if not row:
                abort(403)
            return fn(*args, **kwargs)
        return wrapper
    return deco



  Then:
@bp.route("/landlord/houses/<int:hid>/photos")
@owns_house("hid")
def house_photos(hid): ...







What to audit now (checklist)
	•	All landlord house routes: view, edit, delete, photos, floor plans, EPC, etc.
	•	All landlord room routes: list, create, edit, delete, room photos.
	•	Any POST actions that change data (set primary image, delete image, etc.).
	•	API/JSON/debug endpoints under landlord scope.
	•	Templates: ensure action URLs also include required IDs so the server can re-check ownership.

Response policy
	•	Prefer 403 Forbidden for “you’re not allowed” (reveals less about existence but still clear).
	•	Alternatively use 404 Not Found to avoid confirming the resource exists. Pick one and be consistent.

Extra hardening (nice to have)
	•	Rate-limit landlord endpoints.
	•	Log denied attempts with landlord ID and target ID.
	•	Minimize ID guessing by using slugs/UUIDs for public pages (admin can still use numeric IDs internally).

Bottom line
	•	This is a classic authorization gap. Add a mandatory ownership check to every landlord route (and nested resources) and abort when the check fails.
